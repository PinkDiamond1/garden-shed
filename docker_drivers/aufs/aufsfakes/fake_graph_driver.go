// This file was generated by counterfeiter
package aufsfakes

import (
	"sync"

	"code.cloudfoundry.org/garden-shed/docker_drivers/aufs"
	"github.com/docker/docker/pkg/archive"
)

type FakeGraphDriver struct {
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct{}
	stringReturns     struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	CreateStub        func(id, parent string) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		id     string
		parent string
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveStub        func(id string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		id string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(id, mountLabel string) (dir string, err error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		id         string
		mountLabel string
	}
	getReturns struct {
		result1 string
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	PutStub        func(id string) error
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		id string
	}
	putReturns struct {
		result1 error
	}
	putReturnsOnCall map[int]struct {
		result1 error
	}
	ExistsStub        func(id string) bool
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		id string
	}
	existsReturns struct {
		result1 bool
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
	}
	StatusStub        func() [][2]string
	statusMutex       sync.RWMutex
	statusArgsForCall []struct{}
	statusReturns     struct {
		result1 [][2]string
	}
	statusReturnsOnCall map[int]struct {
		result1 [][2]string
	}
	GetMetadataStub        func(id string) (map[string]string, error)
	getMetadataMutex       sync.RWMutex
	getMetadataArgsForCall []struct {
		id string
	}
	getMetadataReturns struct {
		result1 map[string]string
		result2 error
	}
	getMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	CleanupStub        func() error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct{}
	cleanupReturns     struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	DiffStub        func(id, parent string) (archive.Archive, error)
	diffMutex       sync.RWMutex
	diffArgsForCall []struct {
		id     string
		parent string
	}
	diffReturns struct {
		result1 archive.Archive
		result2 error
	}
	diffReturnsOnCall map[int]struct {
		result1 archive.Archive
		result2 error
	}
	ChangesStub        func(id, parent string) ([]archive.Change, error)
	changesMutex       sync.RWMutex
	changesArgsForCall []struct {
		id     string
		parent string
	}
	changesReturns struct {
		result1 []archive.Change
		result2 error
	}
	changesReturnsOnCall map[int]struct {
		result1 []archive.Change
		result2 error
	}
	ApplyDiffStub        func(id, parent string, diff archive.ArchiveReader) (size int64, err error)
	applyDiffMutex       sync.RWMutex
	applyDiffArgsForCall []struct {
		id     string
		parent string
		diff   archive.ArchiveReader
	}
	applyDiffReturns struct {
		result1 int64
		result2 error
	}
	applyDiffReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	DiffSizeStub        func(id, parent string) (size int64, err error)
	diffSizeMutex       sync.RWMutex
	diffSizeArgsForCall []struct {
		id     string
		parent string
	}
	diffSizeReturns struct {
		result1 int64
		result2 error
	}
	diffSizeReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGraphDriver) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct{}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringReturns.result1
}

func (fake *FakeGraphDriver) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeGraphDriver) StringReturns(result1 string) {
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGraphDriver) StringReturnsOnCall(i int, result1 string) {
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGraphDriver) Create(id string, parent string) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		id     string
		parent string
	}{id, parent})
	fake.recordInvocation("Create", []interface{}{id, parent})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(id, parent)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createReturns.result1
}

func (fake *FakeGraphDriver) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeGraphDriver) CreateArgsForCall(i int) (string, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].id, fake.createArgsForCall[i].parent
}

func (fake *FakeGraphDriver) CreateReturns(result1 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) CreateReturnsOnCall(i int, result1 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) Remove(id string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("Remove", []interface{}{id})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeReturns.result1
}

func (fake *FakeGraphDriver) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeGraphDriver) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return fake.removeArgsForCall[i].id
}

func (fake *FakeGraphDriver) RemoveReturns(result1 error) {
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) RemoveReturnsOnCall(i int, result1 error) {
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) Get(id string, mountLabel string) (dir string, err error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		id         string
		mountLabel string
	}{id, mountLabel})
	fake.recordInvocation("Get", []interface{}{id, mountLabel})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(id, mountLabel)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakeGraphDriver) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeGraphDriver) GetArgsForCall(i int) (string, string) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].id, fake.getArgsForCall[i].mountLabel
}

func (fake *FakeGraphDriver) GetReturns(result1 string, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) GetReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) Put(id string) error {
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("Put", []interface{}{id})
	fake.putMutex.Unlock()
	if fake.PutStub != nil {
		return fake.PutStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putReturns.result1
}

func (fake *FakeGraphDriver) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *FakeGraphDriver) PutArgsForCall(i int) string {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return fake.putArgsForCall[i].id
}

func (fake *FakeGraphDriver) PutReturns(result1 error) {
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) PutReturnsOnCall(i int, result1 error) {
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) Exists(id string) bool {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("Exists", []interface{}{id})
	fake.existsMutex.Unlock()
	if fake.ExistsStub != nil {
		return fake.ExistsStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.existsReturns.result1
}

func (fake *FakeGraphDriver) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeGraphDriver) ExistsArgsForCall(i int) string {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return fake.existsArgsForCall[i].id
}

func (fake *FakeGraphDriver) ExistsReturns(result1 bool) {
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGraphDriver) ExistsReturnsOnCall(i int, result1 bool) {
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGraphDriver) Status() [][2]string {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct{}{})
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.statusReturns.result1
}

func (fake *FakeGraphDriver) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeGraphDriver) StatusReturns(result1 [][2]string) {
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 [][2]string
	}{result1}
}

func (fake *FakeGraphDriver) StatusReturnsOnCall(i int, result1 [][2]string) {
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 [][2]string
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 [][2]string
	}{result1}
}

func (fake *FakeGraphDriver) GetMetadata(id string) (map[string]string, error) {
	fake.getMetadataMutex.Lock()
	ret, specificReturn := fake.getMetadataReturnsOnCall[len(fake.getMetadataArgsForCall)]
	fake.getMetadataArgsForCall = append(fake.getMetadataArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("GetMetadata", []interface{}{id})
	fake.getMetadataMutex.Unlock()
	if fake.GetMetadataStub != nil {
		return fake.GetMetadataStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getMetadataReturns.result1, fake.getMetadataReturns.result2
}

func (fake *FakeGraphDriver) GetMetadataCallCount() int {
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	return len(fake.getMetadataArgsForCall)
}

func (fake *FakeGraphDriver) GetMetadataArgsForCall(i int) string {
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	return fake.getMetadataArgsForCall[i].id
}

func (fake *FakeGraphDriver) GetMetadataReturns(result1 map[string]string, result2 error) {
	fake.GetMetadataStub = nil
	fake.getMetadataReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) GetMetadataReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.GetMetadataStub = nil
	if fake.getMetadataReturnsOnCall == nil {
		fake.getMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) Cleanup() error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct{}{})
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupReturns.result1
}

func (fake *FakeGraphDriver) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeGraphDriver) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) CleanupReturnsOnCall(i int, result1 error) {
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGraphDriver) Diff(id string, parent string) (archive.Archive, error) {
	fake.diffMutex.Lock()
	ret, specificReturn := fake.diffReturnsOnCall[len(fake.diffArgsForCall)]
	fake.diffArgsForCall = append(fake.diffArgsForCall, struct {
		id     string
		parent string
	}{id, parent})
	fake.recordInvocation("Diff", []interface{}{id, parent})
	fake.diffMutex.Unlock()
	if fake.DiffStub != nil {
		return fake.DiffStub(id, parent)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffReturns.result1, fake.diffReturns.result2
}

func (fake *FakeGraphDriver) DiffCallCount() int {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return len(fake.diffArgsForCall)
}

func (fake *FakeGraphDriver) DiffArgsForCall(i int) (string, string) {
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	return fake.diffArgsForCall[i].id, fake.diffArgsForCall[i].parent
}

func (fake *FakeGraphDriver) DiffReturns(result1 archive.Archive, result2 error) {
	fake.DiffStub = nil
	fake.diffReturns = struct {
		result1 archive.Archive
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) DiffReturnsOnCall(i int, result1 archive.Archive, result2 error) {
	fake.DiffStub = nil
	if fake.diffReturnsOnCall == nil {
		fake.diffReturnsOnCall = make(map[int]struct {
			result1 archive.Archive
			result2 error
		})
	}
	fake.diffReturnsOnCall[i] = struct {
		result1 archive.Archive
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) Changes(id string, parent string) ([]archive.Change, error) {
	fake.changesMutex.Lock()
	ret, specificReturn := fake.changesReturnsOnCall[len(fake.changesArgsForCall)]
	fake.changesArgsForCall = append(fake.changesArgsForCall, struct {
		id     string
		parent string
	}{id, parent})
	fake.recordInvocation("Changes", []interface{}{id, parent})
	fake.changesMutex.Unlock()
	if fake.ChangesStub != nil {
		return fake.ChangesStub(id, parent)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.changesReturns.result1, fake.changesReturns.result2
}

func (fake *FakeGraphDriver) ChangesCallCount() int {
	fake.changesMutex.RLock()
	defer fake.changesMutex.RUnlock()
	return len(fake.changesArgsForCall)
}

func (fake *FakeGraphDriver) ChangesArgsForCall(i int) (string, string) {
	fake.changesMutex.RLock()
	defer fake.changesMutex.RUnlock()
	return fake.changesArgsForCall[i].id, fake.changesArgsForCall[i].parent
}

func (fake *FakeGraphDriver) ChangesReturns(result1 []archive.Change, result2 error) {
	fake.ChangesStub = nil
	fake.changesReturns = struct {
		result1 []archive.Change
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) ChangesReturnsOnCall(i int, result1 []archive.Change, result2 error) {
	fake.ChangesStub = nil
	if fake.changesReturnsOnCall == nil {
		fake.changesReturnsOnCall = make(map[int]struct {
			result1 []archive.Change
			result2 error
		})
	}
	fake.changesReturnsOnCall[i] = struct {
		result1 []archive.Change
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) ApplyDiff(id string, parent string, diff archive.ArchiveReader) (size int64, err error) {
	fake.applyDiffMutex.Lock()
	ret, specificReturn := fake.applyDiffReturnsOnCall[len(fake.applyDiffArgsForCall)]
	fake.applyDiffArgsForCall = append(fake.applyDiffArgsForCall, struct {
		id     string
		parent string
		diff   archive.ArchiveReader
	}{id, parent, diff})
	fake.recordInvocation("ApplyDiff", []interface{}{id, parent, diff})
	fake.applyDiffMutex.Unlock()
	if fake.ApplyDiffStub != nil {
		return fake.ApplyDiffStub(id, parent, diff)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.applyDiffReturns.result1, fake.applyDiffReturns.result2
}

func (fake *FakeGraphDriver) ApplyDiffCallCount() int {
	fake.applyDiffMutex.RLock()
	defer fake.applyDiffMutex.RUnlock()
	return len(fake.applyDiffArgsForCall)
}

func (fake *FakeGraphDriver) ApplyDiffArgsForCall(i int) (string, string, archive.ArchiveReader) {
	fake.applyDiffMutex.RLock()
	defer fake.applyDiffMutex.RUnlock()
	return fake.applyDiffArgsForCall[i].id, fake.applyDiffArgsForCall[i].parent, fake.applyDiffArgsForCall[i].diff
}

func (fake *FakeGraphDriver) ApplyDiffReturns(result1 int64, result2 error) {
	fake.ApplyDiffStub = nil
	fake.applyDiffReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) ApplyDiffReturnsOnCall(i int, result1 int64, result2 error) {
	fake.ApplyDiffStub = nil
	if fake.applyDiffReturnsOnCall == nil {
		fake.applyDiffReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.applyDiffReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) DiffSize(id string, parent string) (size int64, err error) {
	fake.diffSizeMutex.Lock()
	ret, specificReturn := fake.diffSizeReturnsOnCall[len(fake.diffSizeArgsForCall)]
	fake.diffSizeArgsForCall = append(fake.diffSizeArgsForCall, struct {
		id     string
		parent string
	}{id, parent})
	fake.recordInvocation("DiffSize", []interface{}{id, parent})
	fake.diffSizeMutex.Unlock()
	if fake.DiffSizeStub != nil {
		return fake.DiffSizeStub(id, parent)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diffSizeReturns.result1, fake.diffSizeReturns.result2
}

func (fake *FakeGraphDriver) DiffSizeCallCount() int {
	fake.diffSizeMutex.RLock()
	defer fake.diffSizeMutex.RUnlock()
	return len(fake.diffSizeArgsForCall)
}

func (fake *FakeGraphDriver) DiffSizeArgsForCall(i int) (string, string) {
	fake.diffSizeMutex.RLock()
	defer fake.diffSizeMutex.RUnlock()
	return fake.diffSizeArgsForCall[i].id, fake.diffSizeArgsForCall[i].parent
}

func (fake *FakeGraphDriver) DiffSizeReturns(result1 int64, result2 error) {
	fake.DiffSizeStub = nil
	fake.diffSizeReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) DiffSizeReturnsOnCall(i int, result1 int64, result2 error) {
	fake.DiffSizeStub = nil
	if fake.diffSizeReturnsOnCall == nil {
		fake.diffSizeReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.diffSizeReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeGraphDriver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.diffMutex.RLock()
	defer fake.diffMutex.RUnlock()
	fake.changesMutex.RLock()
	defer fake.changesMutex.RUnlock()
	fake.applyDiffMutex.RLock()
	defer fake.applyDiffMutex.RUnlock()
	fake.diffSizeMutex.RLock()
	defer fake.diffSizeMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeGraphDriver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ aufs.GraphDriver = new(FakeGraphDriver)
